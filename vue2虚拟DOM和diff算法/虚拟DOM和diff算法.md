### snabbdom 简介

- snabbdom 是著名的虚拟DOM库，是diff算法的鼻祖，vue源码就借鉴了snabbdom；
- [snabbdom 官网](https://github.com/snabbdom/snabbdom)；
- 项目搭建流程及注意事项：
  - snabbdom库时DOM库，里面有html文件，最好运行在浏览器环境上；
  - 如果采用webpack，必须采用webpack@5，不能是webpack@4，因为webpack4没有读取身份证中exports的能力，建议使用webpack@5，webpack-cli@3，webpack-dev-server@3；

### 虚拟DOM

- 虚拟DOM就是用JavaScript对象来描述DOM的层次结构，DOM中的一切属性都在虚拟DOM中有对应的属性；

![](.\image\虚拟DOM简介.png)

### h函数 => 虚拟节点 => 真实DOM

##### 一个虚拟节点都有哪些属性

```
{
	children: undefined, // 子元素
	data: {}, // 真实DOM上的属性和样式
	elm: undefined, // 对应的真正的DOM节点，如果是undefined就表示该虚拟DOM还没有上树
	key: undefined, // 表示这个节点的唯一标识
	sel: "div", // 表示选择器
	text: "我是一个div元素" // 表示文本 
}
```



![h函数 转换 虚拟节点 转换 真实DOM](.\image\h函数 转换 虚拟节点 转换 真实DOM.png)

### diff算法（vue2）

- diff算法可以进行精细化比对，实现最小量更新；diff是发生在虚拟DOM上的，新虚拟DOM和旧虚拟DOM进行diff算法精细化比较，算出应该如何最小量更新，最后反映到真实的DOM上；虚拟DOM变回真正的DOM也是涵盖在diff算法里面的；
- key是这个节点的唯一标识，告诉diff算法，在更改前后它们是同一个DOM节点，只有是**同一个节点（选择器相同且key相同）**，才会进行精细化比较，否则就是暴力删除旧的节点，再插入新的节点；
- 注意diff只进行同层比较，不会进行跨层比较，即使是同一片虚拟节点，但是所在的层级不同，也不会进行精细化比较，而是直接暴力删除旧的，然后插入新的；

##### diff算法的子节点更新策略

- diff算法中，如果新旧节点**没有key**，需要循环遍历新旧节点中比较短的，然后依次对比，如果旧的vnode比较长，就删除；反之，则增加节点；

###### diff 算法的对比顺序（这就是diff算法中**有key时**，新旧vnode的对比顺序******）

循环遍历如下步骤：

- 新前与旧前 (新前: 新vnode的头部；旧后: 旧vnode的尾部)
- 新后与旧后
- 新后与旧前
- 新前与旧后

对比结束后，接下来：

1、如果旧节点先循环完毕，如果新节点中还有剩余节点，就从插入这些新节点；

![diff算法的子节点更新策略（1）](.\image\diff算法的子节点更新策略（1）.png)

2、如果新节点先循环完毕，如果旧节点中还有剩余节点，删除这些旧节点；

![diff算法的子节点更新策略（2）](.\image\diff算法的子节点更新策略（2）.png)

3、如果新旧节点都有剩余，遍历旧节点，根据剩余新节点的key和标签，如果在旧节点中找到相同节点，就将旧节点中的这个节点标记为undefined，然后删除旧节点中的剩余节点；

![diff算法的子节点更新策略（3）](.\image\diff算法的子节点更新策略（3）.png)

4、如果 **新前与旧后** 命中的时候，此时要移动节点，**移动新节点指向的这个节点到旧节点的旧前的前面**；同时，命中的这个 旧后节点 标记为undefined；

![diff算法的子节点更新策略（4）](.\image\diff算法的子节点更新策略（4）.png)

5、如果 **新后与旧前** 命中的时候，此时要移动节点，**移动新节点指向的这个节点到旧节点的旧后的后面**；同时，命中的这个 旧前节点 标记为undefined；

![diff算法的子节点更新策略（5）](.\image\diff算法的子节点更新策略（5）.png)

循环结束条件：` while(新前 <= 新后 && 旧前 <= 旧后){}  `

### patch 函数的整个过程图解

![patch函数的整个过程（1）](.\image\patch函数的整个过程（1）.png)

![patch函数的整个过程（2）](.\image\patch函数的整个过程（2）.png)
